<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sleeper IDP Analyzer - Full Version</title>
    
    <meta name="theme-color" content="#2c3e50">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="IDP Analyzer">
    <meta name="msapplication-TileColor" content="#2c3e50">
    <meta name="description" content="Analyze NFL defensive player matchups and get waiver wire recommendations for fantasy football IDP leagues">
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512x512.png">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #0f1419 0%, #1a1f26 100%); min-height: 100vh; padding: 20px; color: #e6e6e6; }
        .container { max-width: 1400px; margin: 0 auto; background: #1a1f26; border-radius: 15px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); overflow: hidden; border: 1px solid #2d3748; }
        .header { background: linear-gradient(135deg, #1a1f26 0%, #2d3748 100%); color: #e6e6e6; padding: 30px; text-align: center; border-bottom: 2px solid #00d4aa; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; font-weight: 700; color: #00d4aa; }
        .header p { color: #a0aec0; }
        .controls { padding: 30px; background: #2d3748; display: flex; flex-direction: column; gap: 20px; align-items: center; justify-content: center; }
        .control-row { display: flex; gap: 20px; flex-wrap: wrap; width: 100%; justify-content: center; align-items: flex-end; }
        .control-row.main-settings {
            align-items: flex-start;
        }
        .input-group { display: flex; flex-direction: column; gap: 8px; }
        .input-group label { font-weight: 600; color: #e6e6e6; }
        .input-group input, .input-group select { padding: 12px; border: 2px solid #4a5568; border-radius: 8px; font-size: 16px; min-width: 200px; background: #1a1f26; color: #e6e6e6; }
        .input-group input:focus, .input-group select:focus { border-color: #00d4aa; outline: none; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #00d4aa, #00b894); color: #1a1f26; transition: all 0.3s ease; }
        .btn:hover { background: linear-gradient(135deg, #00b894, #00d4aa); transform: translateY(-2px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn.waiver { background: linear-gradient(135deg, #00d4aa, #00b894); }
        .btn.waiver:hover { background: linear-gradient(135deg, #00b894, #00d4aa); }
        .btn.roster { background: linear-gradient(135deg, #667eea, #764ba2); }
        .btn.roster:hover { background: linear-gradient(135deg, #764ba2, #667eea); }
        .btn.load { background: linear-gradient(135deg, #f6e05e, #ecc94b); color: #1a1f26; }
        .btn.load:hover { background: linear-gradient(135deg, #ecc94b, #f6e05e); }
        .position-tabs { display: flex; background: #2d3748; margin: 0 30px; border-radius: 8px; overflow: hidden; flex-wrap: wrap; border: 1px solid #4a5568; }
        .position-tab { flex: 1; min-width: 140px; padding: 15px 10px; background: #2d3748; border: none; cursor: pointer; font-weight: 600; font-size: 0.9rem; transition: all 0.3s ease; color: #a0aec0; text-align: center; border-right: 1px solid #4a5568; }
        .position-tab:last-child { border-right: none; }
        .position-tab.active { background: linear-gradient(135deg, #00d4aa, #00b894); color: #1a1f26; }
        .position-tab:hover:not(.active) { background: #4a5568; color: #e6e6e6; }
        .status { padding: 20px 30px; text-align: center; font-size: 16px; font-weight: 500; background: #1a1f26; }
        .status.loading { color: #00d4aa; }
        .status.error { color: #f56565; background: #2d1b1b; border-left: 4px solid #f56565; }
        .status.success { color: #00d4aa; background: #1a2e25; border-left: 4px solid #00d4aa; }
        .results-section { padding: 30px; background: #1a1f26; }
        .summary-cards { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
        .summary-card { background: linear-gradient(135deg, #2d3748, #4a5568); padding: 20px; border-radius: 12px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); border: 1px solid #4a5568; }
        .summary-card h3 { color: #a0aec0; font-size: 0.9rem; margin-bottom: 8px; text-transform: uppercase; }
        .summary-card .value { font-size: 2rem; font-weight: 700; color: #00d4aa; }
        .table-container { background: #2d3748; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); border: 1px solid #4a5568; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th { background: linear-gradient(135deg, #1a1f26, #2d3748); color: #00d4aa; padding: 16px 12px; text-align: left; font-weight: 600; text-transform: uppercase; font-size: 0.85rem; border-bottom: 2px solid #00d4aa; white-space: nowrap; }
        td { padding: 14px 12px; border-bottom: 1px solid #4a5568; color: #e6e6e6; }
        tr:hover { background-color: #374151; }
        .rank { font-weight: 700; text-align: center; min-width: 50px; }
        .team-name { font-weight: 600; color: #e6e6e6; }
        .points { font-weight: 700; text-align: center; }
        .rank-1-8 { background-color: rgba(72, 187, 120, 0.2) !important; border-left: 4px solid #48bb78; }
        .rank-9-16 { background-color: rgba(255, 235, 59, 0.2) !important; border-left: 4px solid #ffeb3b; }
        .rank-17-24 { background-color: rgba(255, 152, 0, 0.2) !important; border-left: 4px solid #ff9800; }
        .rank-25-32 { background-color: rgba(245, 101, 101, 0.2) !important; border-left: 4px solid #f56565; }
        .legend { display: flex; gap: 20px; justify-content: center; margin: 20px 0; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; font-weight: 500; color: #e6e6e6; }
        .legend-color { width: 20px; height: 20px; border-radius: 4px; border: 1px solid #4a5568; }
        .legend .rank-1-8 .legend-color { background-color: #48bb78; }
        .legend .rank-9-16 .legend-color { background-color: #ffeb3b; }
        .legend .rank-17-24 .legend-color { background-color: #ff9800; }
        .legend .rank-25-32 .legend-color { background-color: #f56565; }
        
        .waiver-section { 
            margin-top: 40px; 
            padding: 25px; 
            background: linear-gradient(135deg, #2d3748, #1a1f26); 
            border-radius: 12px; 
            border: 2px solid #00d4aa; 
        }
        .waiver-header { text-align: center; margin-bottom: 20px; }
        .waiver-header h2 { color: #00d4aa; font-size: 1.8rem; margin-bottom: 10px; }
        .waiver-header p { color: #a0aec0; }
        .waiver-recommendations { display: flex; flex-direction: column; gap: 25px; }
        .waiver-top-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
        .waiver-bottom-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; max-width: 66.67%; margin: 0 auto; }
        .waiver-card { background: #2d3748; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); border: 2px solid #00d4aa; text-align: center; }
        .waiver-card h3 { color: #00d4aa; font-size: 1.2rem; margin-bottom: 15px; }
        .waiver-option { 
            margin-bottom: 0; 
            padding: 15px; 
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .waiver-option:last-child { margin-bottom: 0; }
        .player-name { font-size: 1.1rem; font-weight: 600; color: #e6e6e6; margin-bottom: 5px; }
        .matchup { color: #a0aec0; margin-bottom: 5px; }

        .roster-section { 
            margin-top: 30px; 
            padding: 25px; 
            background: linear-gradient(135deg, #2d3748, #1a1f26); 
            border-radius: 12px; 
            border: 2px solid #667eea; 
        }
        .roster-header { text-align: center; margin-bottom: 20px; }
        .roster-header h2 { color: #667eea; font-size: 1.8rem; margin-bottom: 10px; }
        .roster-header p { color: #a0aec0; margin-bottom: 15px; }
        .roster-section-label { color: #667eea; font-size: 1.3rem; font-weight: 600; margin: 25px 0 15px 0; padding-bottom: 10px; border-bottom: 2px solid #667eea; }
        .roster-section-label:first-of-type { margin-top: 0; }
        .roster-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .roster-player { 
            background: #2d3748; 
            padding: 15px; 
            border-radius: 8px; 
            border-left: 4px solid #4a5568;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .roster-player.rank-1-8 { background-color: rgba(72, 187, 120, 0.15); border-left-color: #48bb78; }
        .roster-player.rank-9-16 { background-color: rgba(255, 235, 59, 0.15); border-left-color: #ffeb3b; }
        .roster-player.rank-17-24 { background-color: rgba(255, 152, 0, 0.15); border-left-color: #ff9800; }
        .roster-player.rank-25-32 { background-color: rgba(245, 101, 101, 0.15); border-left-color: #f56565; }
        .roster-player-name { font-size: 1.1rem; font-weight: 600; color: #e6e6e6; margin-bottom: 5px; }
        .roster-player-position { color: #00d4aa; font-size: 0.9rem; font-weight: 600; margin-bottom: 8px; }
        .roster-player-matchup { color: #a0aec0; font-size: 0.9rem; margin-bottom: 5px; }
        .roster-player-rank { color: #e6e6e6; font-size: 0.85rem; }

        .schedule-table-container {
            margin-top: 10px;
            padding: 5px;
            background: #1a1f26;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #4a5568;
            display: none;
            width: 90%;
            margin-left: auto;
            margin-right: auto;
        }
        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
            color: #e6e6e6;
        }
        .schedule-table th, .schedule-table td {
            padding: 4px 6px;
            text-align: center;
        }
        .schedule-table th {
            color: #00d4aa;
            font-weight: 600;
            border-bottom: 1px solid #4a5568;
        }
        .schedule-table td.rank-1-8 { background-color: #48bb78; }
        .schedule-table td.rank-9-16 { background-color: #ffeb3b; color: #1a1f26; }
        .schedule-table td.rank-17-24 { background-color: #ff9800; }
        .schedule-table td.rank-25-32 { background-color: #f56565; }

        .schedule-toggle-btn {
            background: none;
            border: 1px solid #667eea;
            color: #667eea;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            margin-top: 5px;
            transition: all 0.2s ease;
        }
        .schedule-toggle-btn:hover {
            background: #667eea;
            color: #1a1f26;
        }
        
        @media (max-width: 768px) {
            .controls { padding: 20px; }
            .position-tabs { margin: 0 15px; }
            .position-tab { font-size: 0.8rem; padding: 12px 8px; min-width: 100px; }
            .results-section { padding: 20px 15px; }
            .summary-cards { grid-template-columns: repeat(2, 1fr); }
            .waiver-top-row { grid-template-columns: 1fr; }
            .waiver-bottom-row { grid-template-columns: 1fr; max-width: 100%; }
            .roster-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Sleeper IDP Analyzer - Full Version</h1>
            <p>Ranking ALL 32 NFL OFFENSIVE teams by fantasy points they ALLOW to defensive players (including dual threat analysis)</p>
        </div>

        <div class="controls">
            <div class="control-row">
                <div class="input-group">
                    <label for="username">Sleeper Username: <span style="color: red;">*</span></label>
                    <input type="text" id="username" placeholder="Required - Enter your Username" required>
                </div>
                <button id="loadLeaguesBtn" class="btn load">Load My Leagues</button>
            </div>
            
            <div class="control-row main-settings">
                <div class="input-group">
                    <label for="leagueSelect">Select League: <span style="color: red;">*</span></label>
                    <select id="leagueSelect" disabled>
                        <option value="">(Load leagues first)</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="season">Season:</label>
                    <select id="season">
                        <option value="2025" selected>2025</option>
                        <option value="2024">2024</option>
                        <option value="2023">2023</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="maxWeek">Through Week:</label>
                    <select id="maxWeek">
                        <option value="1">Week 1</option>
                        <option value="2">Week 2</option>
                        <option value="3">Week 3</option>
                        <option value="4" selected>Week 4</option>
                        <option value="5">Week 5</option>
                        <option value="6">Week 6</option>
                        <option value="7">Week 7</option>
                        <option value="8">Week 8</option>
                        <option value="9">Week 9</option>
                        <option value="10">Week 10</option>
                        <option value="11">Week 11</option>
                        <option value="12">Week 12</option>
                        <option value="13">Week 13</option>
                        <option value="14">Week 14</option>
                        <option value="15">Week 15</option>
                        <option value="16">Week 16</option>
                        <option value="17">Week 17</option>
                        <option value="18">Week 18</option>
                    </select>
                </div>
            </div>
            
            <div class="control-row" style="align-items: center;">
                <button id="analyzeBtn" class="btn" disabled>Analyze Selected League</button>
                <div style="display: flex; gap: 10px;">
                    <button id="waiverBtn" class="btn waiver" style="display: none;">Get Waiver Recommendations</button>
                    <button id="rosterBtn" class="btn roster" style="display: none;">Analyse Roster</button>
                </div>
            </div>
        </div>

        <div class="position-tabs" style="display: none;" id="positionTabs">
            <button class="position-tab active" onclick="showPosition('DL')" data-position="DL">
                Defensive Line (DL)
            </button>
            <button class="position-tab" onclick="showPosition('LB')" data-position="LB">
                Linebackers (LB)
            </button>
            <button class="position-tab" onclick="showPosition('DB')" data-position="DB">
                Defensive Backs (DB)
            </button>
            <button class="position-tab" onclick="showPosition('DL/LB')" data-position="DL/LB">
                DL/LB Dual (Best of Both)
            </button>
            <button class="position-tab" onclick="showPosition('LB/DB')" data-position="LB/DB">
                LB/DB Dual (Best of Both)
            </button>
        </div>

        <div id="status" class="status">Enter your Sleeper Username and click "Load My Leagues"</div>

        <div id="resultsSection" class="results-section" style="display: none;">
            <div class="legend">
                <div class="legend-item rank-1-8">
                    <div class="legend-color"></div>
                    <span>1-8 (WORST Offenses - Allow Most Points)</span>
                </div>
                <div class="legend-item rank-9-16">
                    <div class="legend-color"></div>
                    <span>9-16</span>
                </div>
                <div class="legend-item rank-17-24">
                    <div class="legend-color"></div>
                    <span>17-24</span>
                </div>
                <div class="legend-item rank-25-32">
                    <div class="legend-color"></div>
                    <span>25-32 (BEST Offenses - Allow Fewest Points)</span>
                </div>
            </div>

            <div class="summary-cards" id="summaryCards"></div>

            <div class="table-container">
                <table id="resultsTable">
                    <thead id="resultsTableHead">
                        <tr>
                            <th>Rank</th>
                            <th>Offensive Team</th>
                            <th id="tableHeaderText">Points ALLOWED to Defense</th>
                            <th>Avg Per Game</th>
                            <th>Games Played</th>
                            <th>Best Single Game (Most Allowed)</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                    </tbody>
                </table>
            </div>

            <div id="rosterSection" class="roster-section" style="display: none;">
                <div class="roster-header">
                    <h2>Your IDP Lineup Analysis</h2>
                    <p>Color-coded by opponent matchup quality for next week</p>
                    </div>
                <div id="rosterContent">
                </div>
            </div>

            <div id="waiverSection" class="waiver-section" style="display: none;">
                <div class="waiver-header">
                    <h2>Waiver Wire Recommendations</h2>
                    <p>Top 2 available players with favorable matchups (vs top 12 worst offenses) and significant snap percentages (50%+) for next week</p>
                </div>
                <div id="waiverRecommendations" class="waiver-recommendations">
                </div>
            </div>
        </div>
    </div>

    <script>
        class SleeperIDPAnalyzer {
            constructor() {
                this.players = {};
                this.scoringSettings = null;
                this.nflSchedule = {};
                this.leagueRosters = [];
                this.playerStats = {};
                this.teamSnapCounts = {};
                this.userId = null;
                this.userRoster = null;
                this.rosterSettings = null;
                this.cachedRosterData = null;
                this.setupEventListeners();
                this.currentLeagueId = null; 
                this.currentPositionFilter = 'DL';

                this.results = {
                    DL: {},
                    LB: {},
                    DB: {},
                    'DL/LB': {},
                    'LB/DB': {}
                };

                this.teamMappings = {
                    'ARI': 'Arizona Cardinals', 'ATL': 'Atlanta Falcons', 'BAL': 'Baltimore Ravens',
                    'BUF': 'Buffalo Bills', 'CAR': 'Carolina Panthers', 'CHI': 'Chicago Bears',
                    'CIN': 'Cincinnati Bengals', 'CLE': 'Cleveland Browns', 'DAL': 'Dallas Cowboys',
                    'DEN': 'Denver Broncos', 'DET': 'Detroit Lions', 'GB': 'Green Bay Packers',
                    'HOU': 'Houston Texans', 'IND': 'Indianapolis Colts', 'JAX': 'Jacksonville Jaguars',
                    'KC': 'Kansas City Chiefs', 'LV': 'Las Vegas Raiders', 'LAC': 'Los Angeles Chargers',
                    'LAR': 'Los Angeles Rams', 'MIA': 'Miami Dolphins', 'MIN': 'Minnesota Vikings',
                    'NE': 'New England Patriots', 'NO': 'New Orleans Saints', 'NYG': 'New York Giants',
                    'NYJ': 'New York Jets', 'PHI': 'Philadelphia Eagles', 'PIT': 'Pittsburgh Steelers',
                    'SF': 'San Francisco 49ers', 'SEA': 'Seattle Seahawks', 'TB': 'Tampa Bay Buccaneers',
                    'TEN': 'Tennessee Titans', 'WAS': 'Washington Commanders'
                };

                this.espnTeamMap = {
                    'ARI': 'ARI', 'ATL': 'ATL', 'BAL': 'BAL', 'BUF': 'BUF', 'CAR': 'CAR', 'CHI': 'CHI',
                    'CIN': 'CIN', 'CLE': 'CLE', 'DAL': 'DAL', 'DEN': 'DEN', 'DET': 'DET', 'GB': 'GB',
                    'HOU': 'HOU', 'IND': 'IND', 'JAX': 'JAX', 'KC': 'KC', 'LV': 'LV', 'LAC': 'LAC',
                    'LAR': 'LAR', 'MIA': 'MIA', 'MIN': 'MIN', 'NE': 'NE', 'NO': 'NO', 'NYG': 'NYG',
                    'NYJ': 'NYJ', 'PHI': 'PHI', 'PIT': 'PIT', 'SF': 'SF', 'SEA': 'SEA', 'TB': 'TB',
                    'TEN': 'TEN', 'WSH': 'WAS', 'LA': 'LAR', 'WAS': 'WAS' 
                };
            }

            setupEventListeners() {
                document.getElementById('loadLeaguesBtn').addEventListener('click', () => {
                    this.loadUserLeagues();
                });
                
                document.getElementById('leagueSelect').addEventListener('change', (e) => {
                    this.currentLeagueId = e.target.value;
                    const analyzeBtn = document.getElementById('analyzeBtn');
                    analyzeBtn.disabled = !this.currentLeagueId;
                    
                    if (this.currentLeagueId) {
                         this.showStatus(`League selected. Click "Analyze Selected League" to begin analysis.`, 'success');
                    } else {
                         this.showStatus(`Please select a league.`, 'error');
                    }
                });

                document.getElementById('analyzeBtn').addEventListener('click', () => {
                    if (!this.currentLeagueId) {
                        this.showStatus('Please load and select a Sleeper League first.', 'error');
                        return;
                    }
                    this.analyzeDefensiveMatchups();
                });

                document.getElementById('waiverBtn').addEventListener('click', () => {
                    this.getWaiverRecommendations();
                });

                document.getElementById('rosterBtn').addEventListener('click', () => {
                    this.analyzeUserRoster();
                });

                document.body.addEventListener('click', (e) => {
                    if (e.target.classList.contains('schedule-toggle-btn')) {
                        const targetId = e.target.getAttribute('data-target');
                        const targetEl = document.getElementById(targetId);
                        this.toggleScheduleView(targetEl, e.target);
                    }
                });
            }
            
            async loadUserLeagues() {
                const loadBtn = document.getElementById('loadLeaguesBtn');
                const usernameInput = document.getElementById('username');
                const seasonInput = document.getElementById('season');
                const leagueSelect = document.getElementById('leagueSelect');
                const analyzeBtn = document.getElementById('analyzeBtn');

                loadBtn.disabled = true;
                analyzeBtn.disabled = true;
                leagueSelect.disabled = true;
                leagueSelect.innerHTML = '<option value="">Loading...</option>';

                const username = usernameInput.value.trim();
                const season = seasonInput.value;

                if (!username) {
                    this.showStatus('Please enter a Sleeper Username.', 'error');
                    loadBtn.disabled = false;
                    leagueSelect.innerHTML = '<option value="">(Load leagues first)</option>';
                    return;
                }

                try {
                    this.showStatus(`Finding user ID for ${username}...`, 'loading');
                    const userData = await this.fetchData(`https://api.sleeper.app/v1/user/${username}`);
                    this.userId = userData.user_id;

                    this.showStatus(`Fetching NFL leagues for ${username} in ${season} season...`, 'loading');
                    const leagues = await this.fetchData(`https://api.sleeper.app/v1/user/${this.userId}/leagues/nfl/${season}`);

                    leagueSelect.innerHTML = '<option value="">-- Select a League --</option>';
                    
                    if (leagues.length === 0) {
                        this.showStatus(`No NFL leagues found for ${username} in the ${season} season.`, 'error');
                        leagueSelect.disabled = true;
                    } else {
                        leagues.forEach(league => {
                            const option = document.createElement('option');
                            option.value = league.league_id;
                            option.textContent = league.name;
                            leagueSelect.appendChild(option);
                        });
                        leagueSelect.disabled = false;
                        this.showStatus(`Found ${leagues.length} leagues. Please select one.`, 'success');
                    }
                    
                } catch (error) {
                    this.showStatus(`Error loading leagues: ${error.message}. Check username and season.`, 'error');
                    leagueSelect.innerHTML = '<option value="">(Error loading leagues)</option>';
                    leagueSelect.disabled = true;
                } finally {
                    loadBtn.disabled = false;
                }
            }

            showStatus(message, type = 'loading') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            async fetchData(url) {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                }
                return await response.json();
            }

            calculateTeamSnapCounts(weekStats, week) {
                if (!this.teamSnapCounts[week]) {
                    this.teamSnapCounts[week] = {};
                }

                Object.keys(this.teamMappings).forEach(team => {
                    this.teamSnapCounts[week][team] = 0;
                });

                Object.entries(weekStats).forEach(([playerId, stats]) => {
                    if (!stats || typeof stats !== 'object') return;
                    
                    const masterPlayer = this.players[playerId];
                    if (!masterPlayer || !masterPlayer.team) return;
                    
                    const defensivePositions = this.getDefensivePositions(masterPlayer);
                    if (defensivePositions.length === 0) return;
                    
                    const playerSnaps = stats.def_snp || 0;
                    if (playerSnaps > 0) {
                        const team = this.normalizeTeam(masterPlayer.team);
                        if (playerSnaps > this.teamSnapCounts[week][team]) {
                            this.teamSnapCounts[week][team] = playerSnaps;
                        }
                    }
                });

                Object.keys(this.teamMappings).forEach(team => {
                    if (this.teamSnapCounts[week][team] === 0) {
                        this.teamSnapCounts[week][team] = 70;
                    }
                });
            }

            getBetterRankForDualThreat(opponent, dualCategory) {
                const positions = dualCategory.split('/');
                const pos1 = positions[0];
                const pos2 = positions[1];
                
                const teams1 = Object.entries(this.results[pos1])
                    .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed);
                const rank1 = teams1.findIndex(([team]) => team === opponent) + 1;
                
                const teams2 = Object.entries(this.results[pos2])
                    .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed);
                const rank2 = teams2.findIndex(([team]) => team === opponent) + 1;
                
                return {
                    bestRank: Math.min(rank1, rank2),
                    rank1: rank1,
                    rank2: rank2,
                    bestPosition: rank1 <= rank2 ? pos1 : pos2
                };
            }

            async analyzeDefensiveMatchups() {
                try {
                    const analyzeBtn = document.getElementById('analyzeBtn');
                    analyzeBtn.disabled = true;

                    const leagueId = this.currentLeagueId;
                    const season = document.getElementById('season').value;
                    const maxWeek = parseInt(document.getElementById('maxWeek').value);

                    this.showStatus('Loading league settings...', 'loading');
                    
                    const leagueData = await this.fetchData(`https://api.sleeper.app/v1/league/${leagueId}`);
                    this.scoringSettings = leagueData.scoring_settings || {};
                    this.rosterSettings = leagueData.roster_positions || [];
                    
                    const idpCategories = Object.keys(this.scoringSettings).filter(key => 
                        key.startsWith('idp_') && this.scoringSettings[key] !== 0
                    );
                    
                    if (idpCategories.length === 0) {
                        throw new Error('No IDP scoring found in this league.');
                    }

                    this.showStatus('Loading NFL players...', 'loading');
                    this.players = await this.fetchData('https://api.sleeper.app/v1/players/nfl');

                    this.showStatus('Loading league rosters...', 'loading');
                    this.leagueRosters = await this.fetchData(`https://api.sleeper.app/v1/league/${leagueId}/rosters`);

                    this.showStatus('Loading NFL schedules...', 'loading');
                    await this.loadNFLSchedule(season, maxWeek);

                    this.results = { DL: {}, LB: {}, DB: {}, 'DL/LB': {}, 'LB/DB': {} };
                    this.playerStats = {};
                    this.teamSnapCounts = {};
                    this.initializeResults();

                    let totalRealPlayers = 0;

                    for (let week = 1; week <= maxWeek; week++) {
                        this.showStatus(`Processing Week ${week}...`, 'loading');
                        const weekRealPlayers = await this.processWeekData(season, week);
                        totalRealPlayers += weekRealPlayers;
                        await new Promise(resolve => setTimeout(resolve, 300)); 
                    }

                    if (totalRealPlayers === 0) {
                        throw new Error(`No defensive players found. Check your league settings.`);
                    }

                    this.showStatus('Analysis complete! Select a position tab to view results.', 'success');
                    document.getElementById('positionTabs').style.display = 'flex';
                    document.getElementById('resultsSection').style.display = 'block';
                    document.getElementById('waiverBtn').style.display = 'block';
                    
                    const username = document.getElementById('username').value.trim();
                    if (username) {
                        document.getElementById('rosterBtn').style.display = 'block';
                    }
                    
                    this.showPosition('DL');

                } catch (error) {
                    this.showStatus(error.message, 'error');
                    document.getElementById('positionTabs').style.display = 'none';
                    document.getElementById('resultsSection').style.display = 'none';
                    document.getElementById('waiverBtn').style.display = 'none';
                    document.getElementById('rosterBtn').style.display = 'none';
                } finally {
                    document.getElementById('analyzeBtn').disabled = false;
                }
            }

            analyzePlayerFutureSchedule(player, positionToRank, currentWeek) {
                const numGames = 4;
                const schedule = [];
                const playerTeam = this.normalizeTeam(player.team);

                let rankData = this.results[positionToRank] || {};
                
                for (let week = currentWeek + 2; week <= currentWeek + 1 + numGames; week++) {
                    const weekSchedule = this.nflSchedule[week];
                    let opponent = 'BYE';
                    let rank = 'N/A';
                    let colorClass = '';
                    let positionUsed = positionToRank;

                    if (weekSchedule && weekSchedule[playerTeam]) {
                        opponent = weekSchedule[playerTeam];
                        
                        if (positionToRank.includes('/')) {
                            const teams = Object.entries(this.results[positionToRank])
                                .map(([abbr, stats]) => ({ abbr, ...stats }))
                                .sort((a, b) => b.pointsAllowed - a.pointsAllowed);
                            rank = teams.findIndex(t => t.abbr === opponent) + 1;
                            positionUsed = positionToRank;
                        } else {
                            rankData = this.results[positionToRank];
                            rank = Object.entries(rankData)
                                .map(([abbr, stats]) => ({ abbr, ...stats }))
                                .sort((a, b) => b.pointsAllowed - a.pointsAllowed)
                                .findIndex(t => t.abbr === opponent) + 1;
                        }
                        
                        if (rank && rank !== 'N/A') {
                            if (rank <= 8) colorClass = 'rank-1-8';
                            else if (rank <= 16) colorClass = 'rank-9-16';
                            else if (rank <= 24) colorClass = 'rank-17-24';
                            else if (rank <= 32) colorClass = 'rank-25-32';
                        }
                    }

                    schedule.push({
                        week: week,
                        opponent: opponent,
                        rank: rank,
                        colorClass: colorClass,
                        positionUsed: positionUsed
                    });
                }
                return schedule;
            }

            async analyzeUserRoster() {
                try {
                    const rosterBtn = document.getElementById('rosterBtn');
                    rosterBtn.disabled = true;
                    
                    this.showStatus('Loading your roster...', 'loading');

                    const username = document.getElementById('username').value.trim();
                    
                    if (!username) {
                        throw new Error('Please enter your Sleeper username.');
                    }
                    if (!this.userId) {
                        const userData = await this.fetchData(`https://api.sleeper.app/v1/user/${username}`);
                        this.userId = userData.user_id;
                    }

                    const userRoster = this.leagueRosters.find(r => r.owner_id === this.userId);
                    if (!userRoster) {
                        throw new Error('Could not find your roster in this league. Ensure the league is loaded and your username is correct.');
                    }
                    this.userRoster = userRoster;

                    const currentWeek = parseInt(document.getElementById('maxWeek').value);
                    const nextWeek = currentWeek + 1;
                    const nextWeekSchedule = this.nflSchedule[nextWeek];
                    
                    if (!nextWeekSchedule || Object.keys(nextWeekSchedule).length === 0) {
                        throw new Error(`No schedule found for Week ${nextWeek}. Analysis only runs up to Week ${currentWeek}.`);
                    }

                    const startersOrdered = userRoster.starters || [];
                    const allPlayers = userRoster.players || [];
                    const startersSet = new Set(startersOrdered);
                    
                    const starterAnalysis = [];
                    const benchAnalysis = [];
                    
                    startersOrdered.forEach((playerId, index) => {
                        const playerData = this.analyzePlayerMatchup(playerId, nextWeekSchedule, nextWeek, currentWeek);
                        if (playerData) {
                            playerData.rosterIndex = index;
                            starterAnalysis.push(playerData);
                        }
                    });
                    
                    allPlayers.forEach(playerId => {
                        if (!startersSet.has(playerId)) {
                            const playerData = this.analyzePlayerMatchup(playerId, nextWeekSchedule, nextWeek, currentWeek);
                            if (playerData) {
                                benchAnalysis.push(playerData);
                            }
                        }
                    });

                    if (starterAnalysis.length === 0 && benchAnalysis.length === 0) {
                        throw new Error('No IDP players found in your roster.');
                    }

                    this.cachedRosterData = { starterAnalysis, benchAnalysis, nextWeek, currentWeek };
                    this.displayRosterAnalysis(starterAnalysis, benchAnalysis, nextWeek);
                    document.getElementById('rosterSection').style.display = 'block';
                    this.showStatus('Roster analysis complete!', 'success');

                } catch (error) {
                    this.showStatus(`Roster Error: ${error.message}`, 'error');
                } finally {
                    document.getElementById('rosterBtn').disabled = false;
                }
            }

            analyzePlayerMatchup(playerId, nextWeekSchedule, nextWeek, currentWeek) {
                const player = this.players[playerId];
                if (!player) return null;
                
                const positions = this.getDefensivePositions(player);
                if (positions.length === 0) return null;
                
                const playerTeam = this.normalizeTeam(player.team);
                const opponent = nextWeekSchedule[playerTeam];
                
                if (!opponent) return null;
                
                const dualThreatCategory = this.getDualThreatCategory(positions);
                
                let bestRankData, individualRankData;
                let positionToRankForSchedule = null;
                
                if (dualThreatCategory) {
                    const pos1 = positions[0];
                    const pos2 = positions[1];

                    const teams1 = Object.entries(this.results[pos1])
                        .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed); 
                    const rank1 = teams1.findIndex(([team]) => team === opponent) + 1;
                    const opponentData1 = this.results[pos1][opponent];
                    const avgAllowed1 = opponentData1 && opponentData1.gamesPlayed > 0 
                        ? (opponentData1.pointsAllowed / opponentData1.gamesPlayed).toFixed(1) 
                        : '0.0';
                    
                    const teams2 = Object.entries(this.results[pos2])
                        .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed); 
                    const rank2 = teams2.findIndex(([team]) => team === opponent) + 1;
                    const opponentData2 = this.results[pos2][opponent];
                    const avgAllowed2 = opponentData2 && opponentData2.gamesPlayed > 0 
                        ? (opponentData2.pointsAllowed / opponentData2.gamesPlayed).toFixed(1) 
                        : '0.0';

                    const dualTeams = Object.keys(this.teamMappings).map(teamAbbr => {
                        const p1Data = this.results[pos1][teamAbbr];
                        const p2Data = this.results[pos2][teamAbbr];
                        return {
                            abbr: teamAbbr,
                            combinedPoints: p1Data.pointsAllowed + p2Data.pointsAllowed
                        };
                    }).sort((a, b) => b.combinedPoints - a.combinedPoints);
                    const dualRank = dualTeams.findIndex(t => t.abbr === opponent) + 1;
                    const dualOpponentData1 = this.results[pos1][opponent];
                    const dualOpponentData2 = this.results[pos2][opponent];
                    const combinedPoints = dualOpponentData1.pointsAllowed + dualOpponentData2.pointsAllowed;
                    const gamesPlayed = dualOpponentData1.gamesPlayed;
                    const avgAllowedDual = gamesPlayed > 0 
                        ? (combinedPoints / gamesPlayed).toFixed(1) 
                        : '0.0';

                    bestRankData = {
                        rank: dualRank,
                        position: `${dualThreatCategory}`,
                        avgAllowed: avgAllowedDual
                    };
                    positionToRankForSchedule = dualThreatCategory;
                    
                    individualRankData = {
                        rank1: rank1,
                        rank2: rank2,
                        pos1: pos1,
                        pos2: pos2,
                        avgAllowed1: avgAllowed1,
                        avgAllowed2: avgAllowed2
                    };

                } else {
                    const positionToUse = positions[0];
                    const teams = Object.entries(this.results[positionToUse])
                        .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed); 
                    const rank = teams.findIndex(([team]) => team === opponent) + 1;
                    
                    const opponentData = this.results[positionToUse][opponent];
                    const avgAllowed = opponentData && opponentData.gamesPlayed > 0 
                        ? (opponentData.pointsAllowed / opponentData.gamesPlayed).toFixed(1) 
                        : '0.0';
                    
                    bestRankData = {
                        rank,
                        position: positionToUse,
                        avgAllowed
                    };
                    individualRankData = null;
                    positionToRankForSchedule = positionToUse;
                }

                let futureMatchups = [];
                if (positionToRankForSchedule) {
                    futureMatchups = this.analyzePlayerFutureSchedule(player, positionToRankForSchedule, currentWeek);
                }
                
                return {
                    player,
                    opponent,
                    bestRankData,
                    individualRankData,
                    isDualThreat: !!dualThreatCategory,
                    futureMatchups: futureMatchups
                };
            }

            displayRosterAnalysis(starterAnalysis, benchAnalysis, nextWeek) {
                const container = document.getElementById('rosterContent');
                container.innerHTML = '';

                if (starterAnalysis.length === 0 && benchAnalysis.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #a0aec0;">No IDP players with matchup data found.</p>';
                    return;
                }

                if (starterAnalysis.length > 0) {
                    const startersLabel = document.createElement('div');
                    startersLabel.className = 'roster-section-label';
                    startersLabel.textContent = 'STARTERS';
                    container.appendChild(startersLabel);
                    
                    const startersGrid = document.createElement('div');
                    startersGrid.className = 'roster-grid';
                    
                    starterAnalysis.forEach((playerData) => {
                        const playerCard = this.createPlayerCard(playerData, nextWeek, 'roster');
                        startersGrid.appendChild(playerCard);
                    });
                    
                    container.appendChild(startersGrid);
                }

                if (benchAnalysis.length > 0) {
                    const benchLabel = document.createElement('div');
                    benchLabel.className = 'roster-section-label';
                    benchLabel.textContent = 'BENCH';
                    container.appendChild(benchLabel);
                    
                    const benchGrid = document.createElement('div');
                    benchGrid.className = 'roster-grid';
                    
                    benchAnalysis.forEach((playerData) => {
                        const playerCard = this.createPlayerCard(playerData, nextWeek, 'roster');
                        benchGrid.appendChild(playerCard);
                    });
                    
                    container.appendChild(benchGrid);
                }
            }

            createPlayerCard(playerData, nextWeek, section) {
                const { player, opponent, bestRankData, individualRankData, isDualThreat, futureMatchups } = playerData;
                const playerName = `${player.first_name || ''} ${player.last_name || ''}`.trim();
                const scheduleId = `${section}-${player.player_id}-schedule`;
                
                let rank, position, avgAllowed, detailedPositionInfo = '';
                
                if (isDualThreat) {
                    rank = bestRankData.rank;
                    position = bestRankData.position;
                    avgAllowed = bestRankData.avgAllowed;

                    detailedPositionInfo = ` (${individualRankData.pos1}: #${individualRankData.rank1}, ${individualRankData.pos2}: #${individualRankData.rank2})`;
                }
                else {
                    rank = bestRankData.rank;
                    position = bestRankData.position;
                    avgAllowed = bestRankData.avgAllowed;
                }
                
                let colorClass = '';
                if (rank <= 8) colorClass = 'rank-1-8';
                else if (rank <= 16) colorClass = 'rank-9-16';
                else if (rank <= 24) colorClass = 'rank-17-24';
                else colorClass = 'rank-25-32';

                const playerCard = document.createElement('div');
                playerCard.className = `${section}-player ${colorClass}`;

                let scheduleHTML = this.createScheduleTable(futureMatchups, scheduleId);

                playerCard.innerHTML = `
                    <div class="${section}-player-name">${playerName}</div>
                    <div class="${section}-player-position">${player.position || ''} (${player.team || 'FA'}) - ${position}${detailedPositionInfo}</div>
                    <div class="${section}-player-matchup">vs ${opponent} (Week ${nextWeek})</div>
                    <div class="${section}-player-rank">Opponent Rank: #${rank} (Avg: ${avgAllowed} pts/game)</div>
                    ${futureMatchups.length > 0 ? `<button class="schedule-toggle-btn" data-target="${scheduleId}">View Schedule Strength</button>` : ''}
                    ${scheduleHTML}
                `;
                
                return playerCard;
            }

            createScheduleTable(futureMatchups, id) {
                if (futureMatchups.length === 0) return '';
                
                let tableContent = `
                    <div class="schedule-table-container" id="${id}">
                        <table class="schedule-table">
                            <thead>
                                <tr>
                                    <th>WK</th>
                                    <th>Opp</th>
                                    <th>Rank</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                futureMatchups.forEach(matchup => {
                    const rankDisplay = matchup.rank === 'N/A' ? 'BYE' : `#${matchup.rank}`;
                    const teamDisplay = matchup.opponent === 'BYE' ? 'BYE' : `@${matchup.opponent}`;

                    tableContent += `
                        <tr>
                            <td>${matchup.week}</td>
                            <td>${teamDisplay}</td>
                            <td class="${matchup.colorClass}">${rankDisplay}</td>
                        </tr>
                    `;
                });

                tableContent += `
                            </tbody>
                        </table>
                    </div>
                `;
                return tableContent;
            }

            async loadNFLSchedule(season, maxWeek) {
                this.nflSchedule = {};
                
                for (let week = 1; week <= maxWeek + 5; week++) {
                    try {
                        const url = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?seasontype=2&week=${week}&year=${season}`;
                        const data = await this.fetchData(url);
                        
                        if (!data.events || data.events.length === 0) continue;

                        this.nflSchedule[week] = {};
                        data.events.forEach(game => {
                            if (game.competitions?.[0]?.competitors?.length === 2) {
                                const competitors = game.competitions[0].competitors;
                                const team1 = this.normalizeTeam(competitors[0].team.abbreviation);
                                const team2 = this.normalizeTeam(competitors[1].team.abbreviation);

                                if (team1 && team2) {
                                    this.nflSchedule[week][team1] = team2;
                                    this.nflSchedule[week][team2] = team1;
                                }
                            }
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (error) {
                        console.error(`Error loading NFL schedule for week ${week}:`, error);
                    }
                }
            }

            normalizeTeam(abbr) {
                return this.espnTeamMap[abbr] || abbr; 
            }

            getDualThreatCategory(positions) {
                if (positions.length <= 1) return null;
                
                const positionOrder = { 'DL': 1, 'LB': 2, 'DB': 3 };
                const sortedPositions = [...positions].sort((a, b) => positionOrder[a] - positionOrder[b]);
                
                const dualCategory = sortedPositions.join('/');
                if (dualCategory === 'DL/LB' || dualCategory === 'LB/DB') {
                    return dualCategory;
                }
                return null;
            }

            initializeResults() {
                ['DL', 'LB', 'DB', 'DL/LB', 'LB/DB'].forEach(position => {
                    this.results[position] = {};
                    Object.keys(this.teamMappings).forEach(team => {
                        this.results[position][team] = {
                            name: this.teamMappings[team],
                            pointsAllowed: 0,
                            gamesPlayed: 0,
                            bestSingleGame: 0,
                            weeklyBreakdown: []
                        };
                    });
                });
            }

            async processWeekData(season, week) {
                const weekSchedule = this.nflSchedule[week];
                if (!weekSchedule || Object.keys(weekSchedule).length === 0) {
                    return 0;
                }

                const weeklyTotals = { 
                    DL: new Map(), 
                    LB: new Map(), 
                    DB: new Map(),
                    'DL/LB': new Map(),
                    'LB/DB': new Map()
                };
                
                Object.keys(this.teamMappings).forEach(team => {
                    weeklyTotals.DL.set(team, 0);
                    weeklyTotals.LB.set(team, 0);
                    weeklyTotals.DB.set(team, 0);
                    weeklyTotals['DL/LB'].set(team, 0);
                    weeklyTotals['LB/DB'].set(team, 0);
                });

                let weekStats = null;
                try {
                    const url = `https://api.sleeper.app/v1/stats/nfl/regular/${season}/${week}`;
                    weekStats = await this.fetchData(url);
                    
                    if (!weekStats || Object.keys(weekStats).length === 0) {
                        return 0;
                    }
                } catch (error) {
                    return 0;
                }

                this.calculateTeamSnapCounts(weekStats, week);

                let scoringCount = 0;

                Object.entries(weekStats).forEach(([playerId, stats]) => {
                    if (!stats || typeof stats !== 'object') return;
                    
                    const hasRealStats = Object.keys(stats).some(key => 
                        key.startsWith('idp_') || 
                        ['tkl_solo', 'tkl_ast', 'sck', 'int', 'ff', 'fum_rec', 'pass_def', 'qb_hit'].includes(key)
                    );
                    
                    if (!hasRealStats) return;
                    
                    const masterPlayer = this.players[playerId];
                    if (!masterPlayer || !masterPlayer.team) return;

                    const fantasyPoints = this.calculateFantasyPoints(stats);
                    const defensivePositions = this.getDefensivePositions(masterPlayer); 
                    
                    if (defensivePositions.length === 0 || fantasyPoints <= 0) return;
                    
                    if (!this.playerStats[playerId]) {
                        this.playerStats[playerId] = {
                            player: masterPlayer,
                            totalPoints: 0,
                            weeklyScores: [],
                            weeklySnapCounts: [],
                            weeklySnapPercentages: [],
                            positions: defensivePositions,
                            dualThreatCategory: this.getDualThreatCategory(defensivePositions)
                        };
                    }
                    this.playerStats[playerId].totalPoints += fantasyPoints;
                    this.playerStats[playerId].weeklyScores.push(fantasyPoints);
                    
                    const playerSnapCount = stats.def_snp || 0;
                    const playerTeam = this.normalizeTeam(masterPlayer.team);
                    const teamTotalSnaps = this.teamSnapCounts[week]?.[playerTeam] || 70;
                    const snapPercentage = teamTotalSnaps > 0 ? Math.min((playerSnapCount / teamTotalSnaps) * 100, 100) : 0;
                    
                    this.playerStats[playerId].weeklySnapCounts.push(playerSnapCount);
                    this.playerStats[playerId].weeklySnapPercentages.push(snapPercentage);
                    
                    const avgSnapPercentage = this.playerStats[playerId].weeklySnapPercentages.reduce((sum, pct) => sum + pct, 0) / this.playerStats[playerId].weeklySnapPercentages.length;
                    
                    this.playerStats[playerId].hasSignificantSnaps = avgSnapPercentage >= 50;
                    this.playerStats[playerId].avgSnapPercentage = avgSnapPercentage;
                    
                    scoringCount++;

                    const defenseTeam = this.normalizeTeam(masterPlayer.team);
                    const offenseTeam = weekSchedule[defenseTeam];

                    if (!offenseTeam || !this.results.DL[offenseTeam]) return;

                    defensivePositions.forEach(position => {
                        const currentTotal = weeklyTotals[position].get(offenseTeam) || 0;
                        weeklyTotals[position].set(offenseTeam, currentTotal + fantasyPoints);
                    });

                    const dualThreatCategory = this.getDualThreatCategory(defensivePositions);
                    if (dualThreatCategory && weeklyTotals[dualThreatCategory]) {
                        const currentDualTotal = weeklyTotals[dualThreatCategory].get(offenseTeam) || 0;
                        weeklyTotals[dualThreatCategory].set(offenseTeam, currentDualTotal + fantasyPoints);
                    }
                });

                if (scoringCount === 0) return 0;

                Object.keys(this.teamMappings).forEach(offenseTeam => {
                    const hasPoints = ['DL', 'LB', 'DB', 'DL/LB', 'LB/DB'].some(pos => 
                        weeklyTotals[pos].get(offenseTeam) > 0
                    );
                    
                    if (hasPoints) {
                        ['DL', 'LB', 'DB', 'DL/LB', 'LB/DB'].forEach(position => {
                            const weekPoints = weeklyTotals[position].get(offenseTeam) || 0;
                            
                            this.results[position][offenseTeam].pointsAllowed += weekPoints;
                            this.results[position][offenseTeam].weeklyBreakdown.push(weekPoints);
                            
                            if (weekPoints > this.results[position][offenseTeam].bestSingleGame) {
                                this.results[position][offenseTeam].bestSingleGame = weekPoints;
                            }
                        });
                        
                        this.results['DL'][offenseTeam].gamesPlayed++;
                        ['LB', 'DB', 'DL/LB', 'LB/DB'].forEach(position => {
                            this.results[position][offenseTeam].gamesPlayed = this.results['DL'][offenseTeam].gamesPlayed;
                        });
                    }
                });
                
                return scoringCount;
            }

            calculateFantasyPoints(stats) {
                if (!stats || !this.scoringSettings) return 0;

                let points = 0;
                
                Object.keys(stats).forEach(statKey => {
                    if (this.scoringSettings[statKey] && statKey.startsWith('idp_')) {
                        const multiplier = this.scoringSettings[statKey];
                        const statValue = stats[statKey];
                        
                        if (statValue && statValue > 0) {
                            points += statValue * multiplier;
                        }
                    }
                });

                return Math.round(points * 100) / 100;
            }

            getDefensivePositions(player) {
                const fantasyPositions = player.fantasy_positions || [];
                const eligiblePositions = [];
                
                fantasyPositions.forEach(pos => {
                    if (pos === 'DL' || pos === 'DE' || pos === 'DT') {
                        if (!eligiblePositions.includes('DL')) {
                            eligiblePositions.push('DL');
                        }
                    } else if (pos === 'LB') {
                        if (!eligiblePositions.includes('LB')) {
                            eligiblePositions.push('LB');
                        }
                    } else if (pos === 'DB') {
                        if (!eligiblePositions.includes('DB')) {
                            eligiblePositions.push('DB');
                        }
                    }
                });
                
                const nflPos = (player.position || '').toUpperCase().trim();
                
                if (nflPos === 'EDGE') {
                    if (!eligiblePositions.includes('DL')) {
                        eligiblePositions.push('DL');
                    }
                    if (!eligiblePositions.includes('LB')) {
                        eligiblePositions.push('LB');
                    }
                }
                else if (nflPos === 'DE') {
                    if (!eligiblePositions.includes('DL')) {
                        eligiblePositions.push('DL');
                    }
                    if (fantasyPositions.includes('DE') && !eligiblePositions.includes('LB')) {
                        eligiblePositions.push('LB');
                    }
                }
                else if (['DT', 'NT'].includes(nflPos)) {
                    if (!eligiblePositions.includes('DL')) {
                        eligiblePositions.push('DL');
                    }
                }
                else if (nflPos === 'OLB') {
                    if (!eligiblePositions.includes('LB')) {
                        eligiblePositions.push('LB');
                    }
                    if (!eligiblePositions.includes('DL')) {
                        eligiblePositions.push('DL');
                    }
                }
                else if (['LB', 'ILB', 'MLB', 'ROLB', 'LOLB'].includes(nflPos)) {
                    if (!eligiblePositions.includes('LB')) {
                        eligiblePositions.push('LB');
                    }
                }
                else if (['CB', 'S', 'FS', 'SS', 'DB', 'SAF', 'NB'].includes(nflPos)) {
                    if (!eligiblePositions.includes('DB')) {
                        eligiblePositions.push('DB');
                    }
                }
                
                const positionOrder = { 'DL': 1, 'LB': 2, 'DB': 3 };
                eligiblePositions.sort((a, b) => positionOrder[a] - positionOrder[b]);

                return eligiblePositions;
            }

            async getWaiverRecommendations() {
                try {
                    this.showStatus('Finding waiver recommendations...', 'loading');
                    
                    const currentWeek = parseInt(document.getElementById('maxWeek').value);
                    const nextWeek = currentWeek + 1;
                    const nextWeekSchedule = this.nflSchedule[nextWeek];
                    
                    if (!nextWeekSchedule || Object.keys(nextWeekSchedule).length === 0) {
                        throw new Error(`No schedule found for Week ${nextWeek}. Cannot provide waiver recommendations.`);
                    }

                    const rosteredPlayers = new Set();
                    this.leagueRosters.forEach(roster => {
                        if (roster.players) {
                            roster.players.forEach(playerId => rosteredPlayers.add(playerId));
                        }
                    });

                    const recommendations = {};
                    const positionsToAnalyze = ['DL', 'LB', 'DB', 'DL/LB', 'LB/DB'];
                    
                    positionsToAnalyze.forEach(position => {
                        const worstOffenses = Object.entries(this.results[position])
                            .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed)
                            .slice(0, 12)
                            .map(entry => entry[0]);

                        const favorableDefenses = new Set();
                        Object.entries(nextWeekSchedule).forEach(([defenseTeam, offenseTeam]) => {
                            if (worstOffenses.includes(offenseTeam)) {
                                favorableDefenses.add(defenseTeam);
                            }
                        });

                        const availablePlayers = [];
                        Object.entries(this.playerStats).forEach(([playerId, playerData]) => {
                            if (rosteredPlayers.has(playerId)) return;
                            
                            let positionMatch = false;
                            const playerPositions = playerData.positions;
                            const playerDualCategory = playerData.dualThreatCategory;

                            if (['DL', 'LB', 'DB'].includes(position)) {
                                if (playerPositions.includes(position) && !playerDualCategory) {
                                    positionMatch = true;
                                }
                            } else if (position === 'DL/LB') {
                                if (playerPositions.includes('DL') && playerPositions.includes('LB')) {
                                    positionMatch = true;
                                }
                            } else if (position === 'LB/DB') {
                                if (playerPositions.includes('LB') && playerPositions.includes('DB')) {
                                    positionMatch = true;
                                }
                            }
                            
                            if (!positionMatch) return;
                            
                            const playerTeam = this.normalizeTeam(playerData.player.team);
                            if (!favorableDefenses.has(playerTeam)) return;
                            
                            if (!playerData.hasSignificantSnaps) return;
                            
                            const analyzedMatchup = this.analyzePlayerMatchup(playerId, nextWeekSchedule, nextWeek, currentWeek);
                            if (!analyzedMatchup) return;
                            
                            const opponent = analyzedMatchup.opponent;
                            
                            const teams = Object.entries(this.results[position])
                                .sort((a, b) => b[1].pointsAllowed - a[1].pointsAllowed);
                            const opponentRank = teams.findIndex(([team]) => team === opponent) + 1;
                            
                            if (opponentRank > 12) return;
                            
                            const opponentData = this.results[position][opponent];
                            const avgAllowed = opponentData?.pointsAllowed / opponentData?.gamesPlayed || 0;
                            
                            let adjustedTotal = playerData.totalPoints;
                            if (playerData.weeklyScores && playerData.weeklyScores.length > 1) {
                                const sortedScores = [...playerData.weeklyScores].sort((a, b) => b - a);
                                adjustedTotal = playerData.totalPoints - sortedScores[0];
                            }
                            
                            availablePlayers.push({
                                playerId,
                                player: playerData.player,
                                adjustedTotal: adjustedTotal,
                                team: playerTeam,
                                opponent,
                                avgAllowed,
                                snapInfo: `${playerData.avgSnapPercentage.toFixed(1)}%`,
                                opponentRank: opponentRank,
                                futureMatchups: analyzedMatchup.futureMatchups,
                                individualRankData: analyzedMatchup.individualRankData
                            });
                        });

                        availablePlayers.sort((a, b) => b.adjustedTotal - a.adjustedTotal);
                        
                        const top2 = availablePlayers.slice(0, 2);
                        
                        top2.sort((a, b) => a.opponentRank - b.opponentRank);
                        
                        recommendations[position] = top2;
                    });

                    this.displayWaiverRecommendations(recommendations, nextWeek);
                    document.getElementById('waiverSection').style.display = 'block';
                    this.showStatus('Waiver recommendations ready!', 'success');

                } catch (error) {
                    this.showStatus(`Waiver Error: ${error.message}`, 'error');
                }
            }

            displayWaiverRecommendations(recommendations, nextWeek) {
                const container = document.getElementById('waiverRecommendations');
                container.innerHTML = '';

                const waiverContainer = document.createElement('div');
                waiverContainer.className = 'waiver-recommendations';

                const topRow = document.createElement('div');
                topRow.className = 'waiver-top-row';
                
                ['DL', 'LB', 'DB'].forEach(position => {
                    const recs = recommendations[position] || [];
                    const card = document.createElement('div');
                    card.className = 'waiver-card';
                    
                    let cardContent = `<h3>${position} Recommendation</h3>`;
                    
                    if (recs.length === 0) {
                        cardContent += '<p style="color: #a0aec0; font-size: 0.9rem;">No high-snap single-position players with favorable matchups found</p>';
                    } else {
                        recs.forEach((rec, index) => {
                            const playerName = `${rec.player.first_name || ''} ${rec.player.last_name || ''}`.trim();
                            const scheduleId = `waiver-${rec.playerId}-schedule`;
                            
                            let colorClass = '';
                            if (rec.opponentRank <= 8) colorClass = 'rank-1-8';
                            else if (rec.opponentRank <= 16) colorClass = 'rank-9-16';
                            else if (rec.opponentRank <= 24) colorClass = 'rank-17-24';
                            else colorClass = 'rank-25-32';
                            
                            const marginClass = index === 0 ? 'margin-bottom: 15px;' : '';

                            let scheduleHTML = this.createScheduleTable(rec.futureMatchups, scheduleId);
                            
                            cardContent += `
                                <div class="waiver-option ${colorClass}" style="${marginClass}">
                                    <div class="player-name">${playerName} (${rec.player.position || ''})</div>
                                    <div class="matchup">${rec.team} vs ${rec.opponent} (Week ${nextWeek})</div>
                                    <div class="points">Avg Snap Share: ${rec.snapInfo}</div>
                                    <div class="points">Opponent Rank: #${rec.opponentRank} (${rec.avgAllowed.toFixed(1)} pts/game)</div>
                                    ${rec.futureMatchups.length > 0 ? `<button class="schedule-toggle-btn" data-target="${scheduleId}">View Schedule Strength</button>` : ''}
                                    ${scheduleHTML}
                                </div>
                            `;
                        });
                    }
                    
                    card.innerHTML = cardContent;
                    topRow.appendChild(card);
                });

                const bottomRow = document.createElement('div');
                bottomRow.className = 'waiver-bottom-row';
                
                ['DL/LB', 'LB/DB'].forEach(position => {
                    const recs = recommendations[position] || [];
                    const card = document.createElement('div');
                    card.className = 'waiver-card';
                    
                    let cardContent = `<h3>${position} Recommendation</h3>`;
                    
                    if (recs.length === 0) {
                        cardContent += '<p style="color: #a0aec0; font-size: 0.9rem;">No high-snap dual-threat players with favorable matchups found</p>';
                    } else {
                        recs.forEach((rec, index) => {
                            const playerName = `${rec.player.first_name || ''} ${rec.player.last_name || ''}`.trim();
                            const scheduleId = `waiver-${rec.playerId}-schedule`;
                            
                            let colorClass = '';
                            if (rec.opponentRank <= 8) colorClass = 'rank-1-8';
                            else if (rec.opponentRank <= 16) colorClass = 'rank-9-16';
                            else if (rec.opponentRank <= 24) colorClass = 'rank-17-24';
                            else colorClass = 'rank-25-32';
                            
                            const marginClass = index === 0 ? 'margin-bottom: 15px;' : '';
                            
                            const dualRanks = rec.individualRankData;
                            const rankInfo = `(${dualRanks.pos1}: #${dualRanks.rank1}, ${dualRanks.pos2}: #${dualRanks.rank2})`;
                            const posDisplay = `${position} ${rankInfo}`;

                            let scheduleHTML = this.createScheduleTable(rec.futureMatchups, scheduleId);
                            
                            cardContent += `
                                <div class="waiver-option ${colorClass}" style="${marginClass}">
                                    <div class="player-name">${playerName} (${rec.player.position || ''})</div>
                                    <div class="matchup">${rec.team} vs ${rec.opponent} (Week ${nextWeek})</div>
                                    <div class="points">Avg Snap Share: ${rec.snapInfo}</div>
                                    <div class="points">Opponent Rank: #${rec.opponentRank} (${rec.avgAllowed.toFixed(1)} pts/game)</div>
                                    <div class="points">${rankInfo}</div>
                                    ${rec.futureMatchups.length > 0 ? `<button class="schedule-toggle-btn" data-target="${scheduleId}">View Schedule Strength</button>` : ''}
                                    ${scheduleHTML}
                                </div>
                            `;
                        });
                    }
                    
                    card.innerHTML = cardContent;
                    bottomRow.appendChild(card);
                });

                waiverContainer.appendChild(topRow);
                waiverContainer.appendChild(bottomRow);
                container.appendChild(waiverContainer);
            }

            showPosition(position) {
                document.querySelectorAll('.position-tab').forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.dataset.position === position) {
                        tab.classList.add('active');
                        this.currentPositionFilter = position;
                    }
                });

                this.displayResults(this.results[position], position);
            }

            displayResults(data, position) {
                const tableHead = document.getElementById('resultsTableHead');
                const tableBody = document.getElementById('resultsTableBody');
                
                if (position === 'DL/LB' || position === 'LB/DB') {
                    const positions = position.split('/');
                    const pos1 = positions[0];
                    const pos2 = positions[1];
                    
                    tableHead.innerHTML = `
                        <tr>
                            <th>Rank</th>
                            <th>Offensive Team</th>
                            <th>Pts Allowed ${pos1}</th>
                            <th>Pts Allowed ${pos2}</th>
                            <th>Avg Per Game (${position})</th>
                            <th>Games Played</th>
                            <th>Best Game ${pos1}</th>
                            <th>Best Game ${pos2}</th>
                        </tr>
                    `;
                    
                    // First, get the sorted rankings for each individual position
                    const pos1Sorted = Object.entries(this.results[pos1])
                        .map(([abbr, stats]) => ({ abbr, points: stats.pointsAllowed }))
                        .sort((a, b) => b.points - a.points);
                    
                    const pos2Sorted = Object.entries(this.results[pos2])
                        .map(([abbr, stats]) => ({ abbr, points: stats.pointsAllowed }))
                        .sort((a, b) => b.points - a.points);
                    
                    // Create rank maps for quick lookup
                    const pos1Ranks = {};
                    const pos2Ranks = {};
                    pos1Sorted.forEach((team, index) => { pos1Ranks[team.abbr] = index + 1; });
                    pos2Sorted.forEach((team, index) => { pos2Ranks[team.abbr] = index + 1; });
                    
                    const sortedTeams = Object.keys(this.teamMappings).map(teamAbbr => {
                        const pos1Data = this.results[pos1][teamAbbr];
                        const pos2Data = this.results[pos2][teamAbbr];
                        const combinedData = this.results[position][teamAbbr];
                        
                        return {
                            abbr: teamAbbr,
                            name: combinedData.name,
                            pos1Points: pos1Data.pointsAllowed,
                            pos2Points: pos2Data.pointsAllowed,
                            combinedPoints: pos1Data.pointsAllowed + pos2Data.pointsAllowed,
                            gamesPlayed: combinedData.gamesPlayed,
                            pos1Best: pos1Data.bestSingleGame,
                            pos2Best: pos2Data.bestSingleGame,
                            pos1Rank: pos1Ranks[teamAbbr],
                            pos2Rank: pos2Ranks[teamAbbr]
                        };
                    }).sort((a, b) => b.combinedPoints - a.combinedPoints);
                    
                    const totalPoints = sortedTeams.reduce((sum, team) => sum + team.combinedPoints, 0);
                    const maxWeek = parseInt(document.getElementById('maxWeek').value);

                    document.getElementById('summaryCards').innerHTML = `
                        <div class="summary-card">
                            <h3>Position</h3>
                            <div class="value">${position}</div>
                        </div>
                        <div class="summary-card">
                            <h3>Weeks Analyzed</h3>
                            <div class="value">${maxWeek}</div>
                        </div>
                        <div class="summary-card">
                            <h3>Total Points Allowed</h3>
                            <div class="value">${totalPoints.toFixed(1)}</div>
                        </div>
                        <div class="summary-card">
                            <h3>Teams Analyzed</h3>
                            <div class="value">32</div>
                        </div>
                    `;

                    tableBody.innerHTML = '';
                    sortedTeams.forEach((team, index) => {
                        const rank = index + 1;
                        const avgPerGame = team.gamesPlayed > 0 ? (team.combinedPoints / team.gamesPlayed).toFixed(1) : '0.0';

                        let colorClass = '';
                        if (rank <= 8) colorClass = 'rank-1-8';
                        else if (rank <= 16) colorClass = 'rank-9-16';
                        else if (rank <= 24) colorClass = 'rank-17-24';
                        else colorClass = 'rank-25-32';

                        const row = document.createElement('tr');
                        row.className = colorClass;
                        
                        row.innerHTML = `
                            <td class="rank">${rank}</td>
                            <td class="team-name">${team.abbr} - ${team.name} (${pos1} #${team.pos1Rank}, ${pos2} #${team.pos2Rank})</td>
                            <td class="points">${team.pos1Points.toFixed(1)}</td>
                            <td class="points">${team.pos2Points.toFixed(1)}</td>
                            <td class="points">${avgPerGame}</td>
                            <td class="points">${team.gamesPlayed}</td>
                            <td class="points">${team.pos1Best.toFixed(1)}</td>
                            <td class="points">${team.pos2Best.toFixed(1)}</td>
                        `;
                        tableBody.appendChild(row);
                    });
                } else {
                    tableHead.innerHTML = `
                        <tr>
                            <th>Rank</th>
                            <th>Offensive Team</th>
                            <th>Points ALLOWED to Defense</th>
                            <th>Avg Per Game</th>
                            <th>Games Played</th>
                            <th>Best Single Game (Most Allowed)</th>
                        </tr>
                    `;
                    
                    const sortedTeams = Object.entries(data)
                        .map(([abbr, stats]) => ({ abbr, ...stats }))
                        .sort((a, b) => b.pointsAllowed - a.pointsAllowed);
                    
                    const totalPoints = sortedTeams.reduce((sum, team) => sum + team.pointsAllowed, 0);
                    const maxWeek = parseInt(document.getElementById('maxWeek').value);

                    document.getElementById('summaryCards').innerHTML = `
                        <div class="summary-card">
                            <h3>Position</h3>
                            <div class="value">${position}</div>
                        </div>
                        <div class="summary-card">
                            <h3>Weeks Analyzed</h3>
                            <div class="value">${maxWeek}</div>
                        </div>
                        <div class="summary-card">
                            <h3>Total Points Allowed</h3>
                            <div class="value">${totalPoints.toFixed(1)}</div>
                        </div>
                        <div class="summary-card">
                            <h3>Teams Analyzed</h3>
                            <div class="value">32</div>
                        </div>
                    `;

                    tableBody.innerHTML = '';
                    sortedTeams.forEach((team, index) => {
                        const rank = index + 1;
                        const avgPerGame = team.gamesPlayed > 0 ? (team.pointsAllowed / team.gamesPlayed).toFixed(1) : '0.0';

                        let colorClass = '';
                        if (rank <= 8) colorClass = 'rank-1-8';
                        else if (rank <= 16) colorClass = 'rank-9-16';
                        else if (rank <= 24) colorClass = 'rank-17-24';
                        else colorClass = 'rank-25-32';

                        const row = document.createElement('tr');
                        row.className = colorClass;
                        
                        row.innerHTML = `
                            <td class="rank">${rank}</td>
                            <td class="team-name">${team.abbr} - ${team.name}</td>
                            <td class="points">${team.pointsAllowed.toFixed(1)}</td>
                            <td class="points">${avgPerGame}</td>
                            <td class="points">${team.gamesPlayed}</td>
                            <td class="points">${team.bestSingleGame.toFixed(1)}</td>
                        `;
                        tableBody.appendChild(row);
                    });
                }
            }

            toggleScheduleView(targetEl, button) {
                if (targetEl.style.display === 'block') {
                    targetEl.style.display = 'none';
                    button.textContent = 'View Schedule Strength';
                } else {
                    targetEl.style.display = 'block';
                    button.textContent = 'Hide Schedule Strength';
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.analyzer = new SleeperIDPAnalyzer();
        });

        function showPosition(position) {
            if (window.analyzer) {
                window.analyzer.showPosition(position);
            }
        }
        
    </script>
</body>
</html>
